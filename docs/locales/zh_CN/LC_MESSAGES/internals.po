# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2025, The Ethereum Foundation
# This file is distributed under the same license as the web3.py package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: web3.py 7.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-06 10:49+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../internals.rst:2
msgid "Web3 Internals"
msgstr "Web3 内部实现"

#: ../../internals.rst:5
msgid ""
"This section of the documentation is for advanced users.  You should "
"probably stay away from these APIs if you don't know what you are doing."
msgstr ""

#: ../../internals.rst:7
msgid ""
"The Web3 library has multiple layers of abstraction between the public "
"api exposed by the web3 object and the backend or node that web3 is "
"connecting to."
msgstr ""

#: ../../internals.rst:10
msgid ""
"**Providers** are responsible for the actual communication with the "
"blockchain such as sending JSON-RPC requests over HTTP or an IPC socket."
msgstr ""

#: ../../internals.rst:12
msgid ""
"**Middleware** provide hooks for monitoring and modifying requests and "
"responses to and from the provider."
msgstr ""

#: ../../internals.rst:14
msgid ""
"**Managers** provide thread safety and primitives to allow for "
"asynchronous usage of web3."
msgstr ""

#: ../../internals.rst:16
msgid "Here are some common things you might want to do with these APIs."
msgstr ""

#: ../../internals.rst:18
msgid ""
"Redirect certain RPC requests to different providers such as sending all "
"*read* operations to a provider backed by a remote node and all *write* "
"operations to a local node that you control."
msgstr ""

#: ../../internals.rst:21
msgid ""
"Transparently intercept transactions sent over ``eth_sendTransaction``, "
"sign them locally, and then send them through ``eth_sendRawTransaction``."
msgstr ""

#: ../../internals.rst:23
msgid ""
"Modify the response from an RPC request so that it is returned in "
"different format such as converting all integer values to their "
"hexadecimal representation."
msgstr ""

#: ../../internals.rst:26
msgid "Validate the inputs to RPC requests"
msgstr ""

#: ../../internals.rst:30
msgid "Request Lifecycle"
msgstr ""

#: ../../internals.rst:32
msgid "Each web3 RPC call passes through these layers in the following manner."
msgstr ""

#: ../../internals.rst:56
msgid ""
"You can visualize this relationship like an onion, with the Provider at "
"the center. The request originates from the ``Manager``, outside of the "
"onion, passing down through each layer of the onion until it reaches the "
"``Provider`` at the center. The ``Provider`` then handles the request, "
"producing a response which will then pass back out from the center of the"
" onion, through each layer until it is finally returned by the "
"``Manager``."
msgstr ""

#: ../../internals.rst:65
msgid "Providers"
msgstr ""

#: ../../internals.rst:67
msgid ""
"A provider is responsible for all direct blockchain interactions.  In "
"most cases this means interacting with the JSON-RPC server for an "
"ethereum node over HTTP or an IPC socket.  There is however nothing which"
" requires providers to be RPC based, allowing for providers designed for "
"testing purposes which use an in-memory EVM to fulfill requests."
msgstr ""

#: ../../internals.rst:75
msgid "Writing your own Provider"
msgstr ""

#: ../../internals.rst:77
msgid ""
"Writing your own provider requires implementing two required methods as "
"well as setting the middleware the provider should use."
msgstr ""

#: ../../internals.rst:83
msgid ""
"Each provider class **must** implement this method.  This method "
"**should** return a JSON object with either a ``'result'`` key in the "
"case of success, or an ``'error'`` key in the case of failure."
msgstr ""

#: ../../internals.rst:88
msgid ""
"``method``  This will be a string representing the JSON-RPC method that "
"is being called such as ``'eth_sendTransaction'``."
msgstr ""

#: ../../internals.rst:90
msgid ""
"``params``  This will be a list or other iterable of the parameters for "
"the JSON-RPC method being called."
msgstr ""

#: ../../internals.rst:96
msgid ""
"This function should return ``True`` or ``False`` depending on whether "
"the provider should be considered *connected*.  For example, an IPC "
"socket based provider should return ``True`` if the socket is open and "
"``False`` if the socket is closed."
msgstr ""

#: ../../internals.rst:101
msgid ""
"If set to ``True``, the optional ``show_traceback`` boolean will raise a "
"``ProviderConnectionError`` and provide information on why the provider "
"should not be considered *connected*."
msgstr ""

#: ../../internals.rst:108
msgid "This should be an iterable of middleware."
msgstr ""

#: ../../internals.rst:110
msgid ""
"You can set a new list of middleware by assigning to "
"``provider.middleware``, with the first middleware that processes the "
"request at the beginning of the list."
msgstr ""

#: ../../internals.rst:115
msgid "Provider Configurations"
msgstr ""

#: ../../internals.rst:120
msgid "Request Caching"
msgstr ""

#: ../../internals.rst:123
msgid ""
"Familiarize yourself with the validation logic for request caching before"
" enabling it. Since this feature often requires making additional "
"requests under the hood to try to guarantee the validity of the data, it "
"may create unnecessary overhead for your use case. Validation can be "
"turned off by setting the ``request_cache_validation_threshold`` option "
"to ``None``, caching all allowed requests, or configured for adjusting "
"performance to your needs."
msgstr ""

#: ../../internals.rst:131
msgid ""
"Request caching can be configured at the provider level via the following"
" configuration options on the provider instance:"
msgstr ""

#: ../../internals.rst:134
msgid "``cache_allowed_requests: bool = False``"
msgstr ""

#: ../../internals.rst:135
msgid "``cacheable_requests: Optional[Set[RPCEndpoint]]``"
msgstr ""

#: ../../internals.rst:136
msgid ""
"``request_cache_validation_threshold: "
"Optional[Union[RequestCacheValidationThreshold, int]]``"
msgstr ""

#: ../../internals.rst:138
msgid ""
"For requests that don't rely on block data (e.g., ``eth_chainId``), "
"enabling request caching by setting the ``cache_allowed_requests`` option"
" to ``True`` will cache all responses. This is safe to do."
msgstr ""

#: ../../internals.rst:142
msgid ""
"However, for requests that rely on block data (e.g., "
"``eth_getBlockByNumber``), it is not safe to always cache their responses"
" because block data can change - during a chain reorganization or while "
"finality has not been reached, for example. The "
"``request_cache_validation_threshold`` option allows configuring a safe "
"threshold for caching responses that depend on block data. By default, "
"this option is configured to internal values deemed \"safe\" for the "
"chain id you are connected to. If you are connected to mainnet Ethereum, "
"this value is set to the ``finalized`` block number. If you are connected"
" to another chain, this value is set to a time interval in seconds, from "
"the current time, that is deemed \"safe\" for that chain's finality "
"mechanism."
msgstr ""

#: ../../internals.rst:152
msgid ""
"**It's important to understand that, in order to perform these "
"validations, extra requests are sometimes made to the node to get the "
"appropriate information. For a transaction request, for example, it is "
"necessary to get the block information to validate the transaction is "
"beyond the safe threshold. This can create overhead, especially for high-"
"frequency requests. For this reason, it is important to understand when "
"to turn on caching and how to configure the validation appropriately for "
"your use case in order to avoid unnecessary overhead.**"
msgstr ""

#: ../../internals.rst:160
msgid ""
"We keep a list of some reasonable values for bigger chains and use the "
"time interval of 1 hour for everything else. Below is a list of the "
"default values for internally configured chains:"
msgstr ""

#: ../../internals.rst:164
msgid "ETH: RequestCacheValidationThreshold.FINALIZED (\"finalized\" block)"
msgstr ""

#: ../../internals.rst:165
msgid "ARB1: 7 days"
msgstr ""

#: ../../internals.rst:166
msgid "ZKSYNC: 1 hour"
msgstr ""

#: ../../internals.rst:167
msgid "OETH: 3 minutes"
msgstr ""

#: ../../internals.rst:168
msgid "MATIC: 30 minutes"
msgstr ""

#: ../../internals.rst:169
msgid "ZKEVM: 1 hour"
msgstr ""

#: ../../internals.rst:170
msgid "BASE: 7 days"
msgstr ""

#: ../../internals.rst:171
msgid "SCR: 1 hour"
msgstr ""

#: ../../internals.rst:172
msgid "GNO: 5 minutes"
msgstr ""

#: ../../internals.rst:173
msgid "AVAX: 2 minutes"
msgstr ""

#: ../../internals.rst:174
msgid "BNB: 2 minutes"
msgstr ""

#: ../../internals.rst:175
msgid "FTM: 1 minute"
msgstr ""

#: ../../internals.rst:177
msgid ""
"For Ethereum mainnet, for example, this means that a request's response "
"will be cached if the block number the request relies on is less than or "
"equal to the ``finalized`` block number. If the block number exceeds the "
"``finalized`` block number, the response won't be cached. For all others,"
" the response will be cached if the block timestamp related to the data "
"that is being requested is older than or equal to the time interval "
"configured for that chain. For any chain not on this list, the default "
"value is set to 1 hour (this includes all testnets)."
msgstr ""

#: ../../internals.rst:185
msgid ""
"This behavior can be modified by setting the "
"``request_cache_validation_threshold`` option to "
"``RequestCacheValidationThreshold.SAFE``, which uses the ``safe`` block "
"as the threshold (Ethereum mainnet only), to your own time interval in "
"seconds (for any chain, including mainnet Ethereum), or to ``None``, "
"which disables any validation and caches all requests (this is not "
"recommended for non testnet chains). The "
"``RequestCacheValidationThreshold`` enum, for mainnet ``finalized`` and "
"``safe`` values, is imported from the ``web3.utils`` module."
msgstr ""

#: ../../internals.rst:193
msgid ""
"Note that the ``cacheable_requests`` option can be used to specify a set "
"of RPC endpoints that are allowed to be cached. By default, this option "
"is set to an internal list of deemed-safe-to-cache endpoints, excluding "
"endpoints such as ``eth_call``, whose responses can vary and are not safe"
" to cache. The default list of cacheable requests is below, with requests"
" validated by the ``request_cache_validation_threshold`` option in bold:"
msgstr ""

#: ../../internals.rst:200
msgid "eth_chainId"
msgstr ""

#: ../../internals.rst:201
msgid "web3_clientVersion"
msgstr ""

#: ../../internals.rst:202
msgid "net_version"
msgstr ""

#: ../../internals.rst:203
msgid "**eth_getBlockByNumber**"
msgstr ""

#: ../../internals.rst:204
msgid "**eth_getRawTransactionByBlockNumberAndIndex**"
msgstr ""

#: ../../internals.rst:205
msgid "**eth_getBlockTransactionCountByNumber**"
msgstr ""

#: ../../internals.rst:206
msgid "**eth_getUncleByBlockNumberAndIndex**"
msgstr ""

#: ../../internals.rst:207
msgid "**eth_getUncleCountByBlockNumber**"
msgstr ""

#: ../../internals.rst:208
msgid "**eth_getBlockByHash**"
msgstr ""

#: ../../internals.rst:209
msgid "**eth_getTransactionByHash**"
msgstr ""

#: ../../internals.rst:210
msgid "**eth_getTransactionByBlockNumberAndIndex**"
msgstr ""

#: ../../internals.rst:211
msgid "**eth_getTransactionByBlockHashAndIndex**"
msgstr ""

#: ../../internals.rst:212
msgid "**eth_getBlockTransactionCountByHash**"
msgstr ""

#: ../../internals.rst:213
msgid "**eth_getRawTransactionByBlockHashAndIndex**"
msgstr ""

#: ../../internals.rst:214
msgid "**eth_getUncleByBlockHashAndIndex**"
msgstr ""

#: ../../internals.rst:215
msgid "**eth_getUncleCountByBlockHash**"
msgstr ""

#: ../../internals.rst:239
msgid "Retry Requests for HTTP Providers"
msgstr ""

#: ../../internals.rst:241
msgid ""
"``HTTPProvider`` and ``AsyncHTTPProvider`` instances retry certain "
"requests by default on exceptions. This can be configured via the "
"``exception_retry_configuration`` property on the provider instance, "
"which takes a "
":class:`~web3.providers.rpc.utils.ExceptionRetryConfiguration` class as "
"its value. The retry mechanism employs an exponential backoff strategy, "
"starting from the initial value determined by the ``backoff_factor``, and"
" doubling the delay with each attempt, up to the ``retries`` value. Below"
" is an example showing the default options for the retry configuration "
"and how to override them."
msgstr ""

#: ../../internals.rst:255
msgid ""
"A tuple of exceptions that the provider should retry on. The default is "
"``HTTPProvider``: ``(ConnectionError, requests.HTTPError, "
"requests.Timeout)`` and ``AsyncHTTPProvider``: ``(aiohttp.ClientError, "
"asyncio.TimeoutError)``."
msgstr ""

#: ../../internals.rst:261
msgid "The number of retries to attempt. The default is 5."
msgstr ""

#: ../../internals.rst:265
msgid ""
"The initial delay multiplier, which doubles with each retry attempt. The "
"default is 0.125."
msgstr ""

#: ../../internals.rst:270
msgid ""
"A list of retryable methods. The default is an in-house list of deemed-"
"safe-to- retry methods."
msgstr ""

#: ../../internals.rst:297
msgid "For the different http providers, ``DEFAULT_EXCEPTIONS`` is defined as:"
msgstr ""

#: ../../internals.rst:299
msgid ""
"``HTTPProvider``: ``(ConnectionError, requests.HTTPError, "
"requests.Timeout)``"
msgstr ""

#: ../../internals.rst:300
msgid ""
"``AsyncHTTPProvider``: ``(ConnectionError, aiohttp.ClientError, "
"asyncio.TimeoutError)``"
msgstr ""

#: ../../internals.rst:302
msgid ""
"Setting ``retry_configuration`` to ``None`` will disable retries on "
"exceptions for the provider instance."
msgstr ""

#: ../../internals.rst:314
msgid "Managers"
msgstr ""

#: ../../internals.rst:316
msgid ""
"The Manager acts as a gatekeeper for the request/response lifecycle.  It "
"is unlikely that you will need to change the Manager as most "
"functionality can be implemented in the Middleware layer."
msgstr ""

#: ../../internals.rst:323
msgid "Request Processing for Persistent Connection Providers"
msgstr ""

#: ../../internals.rst:327
msgid ""
"The ``RequestProcessor`` class is responsible for the storing and syncing"
" up of asynchronous requests to responses for a "
"``PersistentConnectionProvider``. The "
":class:`~web3.providers.persistent.WebSocketProvider` and the "
":class:`~web3.providers.persistent.AsyncIPCProvider` are two persistent "
"connection providers. In order to send a request and receive a response "
"to that same request, ``PersistentConnectionProvider`` instances have to "
"match request *id* values to response *id* values coming back from the "
"socket connection. Any provider that does not adhere to the `JSON-RPC 2.0"
" specification <https://www.jsonrpc.org/specification>`_ in this way will"
" not work with ``PersistentConnectionProvider`` instances. The specifics "
"of how the request processor handles this are outlined below."
msgstr ""

#: ../../internals.rst:339
msgid "Listening for Responses"
msgstr ""

#: ../../internals.rst:341
msgid ""
"Implementations of the ``PersistentConnectionProvider`` class have a "
"message listener background task that is called when the socket "
"connection is established. This task is responsible for listening for any"
" and all messages coming in over the socket connection and storing them "
"in the ``RequestProcessor`` instance internal to the "
"``PersistentConnectionProvider`` instance. The ``RequestProcessor`` "
"instance is responsible for storing the messages in the correct cache, "
"either the one-to-one cache or the one-to-many (subscriptions) queue, "
"depending on whether the message has a JSON-RPC *id* value or not."
msgstr ""

#: ../../internals.rst:352
msgid "One-To-One Requests"
msgstr ""

#: ../../internals.rst:354
msgid ""
"One-to-one requests can be summarized as any request that expects only "
"one response back. An example is using the ``eth`` module API to request "
"the latest block number."
msgstr ""

#: ../../internals.rst:366
msgid ""
"With persistent socket connections, we have to call ``send()`` and "
"asynchronously receive responses via another means, generally by calling "
"``recv()`` or by iterating on the socket connection for messages. As "
"outlined above, the ``PersistentConnectionProvider`` class has a message "
"listener background task that handles the receiving of messages."
msgstr ""

#: ../../internals.rst:372
msgid ""
"Due to this asynchronous nature of sending and receiving, in order to "
"make one-to-one request-to-response calls work, we have to save the "
"request information somewhere so that, when the response is received, we "
"can match it to the original request that was made (i.e. the request with"
" a matching *id* to the response that was received). The stored request "
"information is then used to process the response when it is received, "
"piping it through the response formatters and middleware internal to the "
"*web3.py* library."
msgstr ""

#: ../../internals.rst:380
msgid ""
"In order to store the request information, the ``RequestProcessor`` class"
" has an internal ``RequestInformation`` cache. The ``RequestInformation``"
" class saves important information about a request."
msgstr ""

#: ../../internals.rst:388
msgid "The name of the method - e.g. \"eth_subscribe\"."
msgstr ""

#: ../../internals.rst:392
msgid ""
"The params used when the call was made - e.g. "
"(\"newPendingTransactions\", True)."
msgstr ""

#: ../../internals.rst:396
msgid "The formatters that will be used to process the response."
msgstr ""

#: ../../internals.rst:400
msgid ""
"Any middleware that processes responses that is present on the instance "
"at the time of the request is appended here, in order, so the response "
"may be piped through that logic when it comes in."
msgstr ""

#: ../../internals.rst:406
msgid ""
"If the request is an ``eth_subscribe`` request, rather than popping this "
"information from the cache when the response to the subscription call "
"comes in (i.e. the subscription *id*), we save the subscription id with "
"the request information so that we can correctly process all subscription"
" messages that come in with that subscription *id*. For one-to-one "
"request-to-response calls, this value is always ``None``."
msgstr ""

#: ../../internals.rst:413
msgid ""
"One-to-one responses, those that include a JSON-RPC *id* in the response "
"object, are stored in an internal ``SimpleCache`` class, isolated from "
"any one-to-many responses. When the ``PersistentConnectionProvider`` is "
"looking for a response internally, it will expect the message listener "
"task to store the response in this cache. Since the request *id* is used "
"in the cache key generation, it will then look for a cache key that "
"matches the response *id* with that of the request *id*. If the cache key"
" is found, the response is processed and returned to the user. If the "
"cache key is not found, the operation will time out and raise a "
"``TimeExhausted`` exception. This timeout can be configured by the user "
"when instantiating the ``PersistentConnectionProvider`` instance via the "
"``response_timeout`` keyword argument."
msgstr ""

#: ../../internals.rst:425
msgid "One-To-Many Requests"
msgstr ""

#: ../../internals.rst:427
msgid ""
"One-to-many requests can be summarized by any request that expects many "
"responses as a result of the initial request. The only current example is"
" the ``eth_subscribe`` request. The initial ``eth_subscribe`` request "
"expects only one response, the subscription *id* value, but it also "
"expects to receive many ``eth_subscription`` messages if and when the "
"request is successful. For this reason, the original request is "
"considered a one-to-one request so that a subscription *id* can be "
"returned to the user on the same line. The many responses this call will "
"produce can be handled in one of a few ways."
msgstr ""

#: ../../internals.rst:436
msgid ""
"The recommended way to handle one-to-many responses is to use the "
"subscription manager API. The subscription manager API is a public API on"
" the ``AsyncWeb3`` class, when connected to a "
"``PersistentConnectionProvider`` instance, that allows the user to "
"subscribe to a subscription and handle the many responses asynchronously."
" The ``subscription_manager`` instance is responsible for handling the "
"many responses that come in over the socket connection, as long as "
"handlers are passed to each subscription call. The subscription manager "
"can also be used to unsubscribe from a subscription when the user is done"
" with it."
msgstr ""

#: ../../internals.rst:468
msgid ""
"The manager can also subscribe to many subscriptions at one time. The "
"``EthSubscription`` classes, available via ``web3.utils.subscriptions``, "
"provide a friendly API for managing subscriptions. Since each connection "
"and provider instance has its own message listener task and subscription "
"manager instance, you can subscribe to many subscriptions at once and "
"handle the many responses that come in over the socket connections via "
"handlers. The handlers contain:"
msgstr ""

#: ../../internals.rst:475
msgid ""
"``async_w3``: The ``AsyncWeb3`` instance that the subscription was made "
"on."
msgstr ""

#: ../../internals.rst:476
msgid ""
"``subscription``: The subscription instance that the handler is attached "
"to."
msgstr ""

#: ../../internals.rst:477
msgid ""
"``result``: The response that came in over the socket connection for the "
"subscription."
msgstr ""

#: ../../internals.rst:479
msgid ""
"Subscriptions also accept a ``handler_context`` argument that can be used"
" to pass additional information to the handler when subscribing to a "
"subscription. This can be used to pass in an event object, for example, "
"that can be used to parse a log event when it comes in."
msgstr ""

#: ../../internals.rst:571
msgid ""
"The ``process_subscriptions()`` method on the "
":class:`~web3.providers.persistent.PersistentConnection` class, the "
"public API for interacting with the active persistent socket connection, "
"is also set up to receive ``eth_subscription`` responses over an "
"asynchronous iterator pattern. You can use this method to listen for raw "
"messages and process them as they come in."
msgstr ""

#: ../../internals.rst:603
msgid ""
"One-to-many responses, those that do not include a JSON-RPC *id* in the "
"response object, are stored in an internal ``asyncio.Queue`` instance, "
"isolated from any one-to-one responses. When the "
"``PersistentConnectionProvider`` is looking for one-to-many responses "
"internally, it will expect the message listener task to store these "
"messages in this queue. Since the order of the messages is important, the"
" queue is a FIFO queue. The ``process_subscriptions()`` method on the "
"``PersistentConnection`` class is set up to pop messages from this queue "
"as FIFO over an asynchronous iterator pattern."
msgstr ""

#: ../../internals.rst:611
msgid ""
"If the stream of messages from the socket is not being interrupted by any"
" other tasks, the queue will generally be in sync with the messages "
"coming in over the socket. That is, the message listener will put a "
"message in the queue and the ``process_subscriptions()`` method will pop "
"that message from the queue and yield control of the loop back to the "
"listener. This will continue until the socket connection is closed or the"
" user unsubscribes from the subscription. If the stream of messages lags "
"a bit, or the provider is not consuming messages but has subscribed to a "
"subscription, this internal queue may fill up with messages until it "
"reaches its max size and then trigger a waiting ``asyncio.Event`` until "
"the provider begins consuming messages from the queue again. For this "
"reason, it's important to begin consuming messages from the queue, via "
"the ``process_subscriptions()`` method, as soon as a subscription is "
"made."
msgstr ""

