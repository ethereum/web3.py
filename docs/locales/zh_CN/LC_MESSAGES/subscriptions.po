# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2025, The Ethereum Foundation
# This file is distributed under the same license as the web3.py package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: web3.py 7.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-06 10:49+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../subscriptions.rst:4
msgid "Event Subscriptions"
msgstr "事件订阅"

#: ../../subscriptions.rst:6
msgid ""
"Most Ethereum clients include ``eth_subscribe`` support, allowing you to "
"listen for specific events as they occur. This applies to a limited set "
"of events: new block headers, the syncing status of a node, new pending "
"transactions, and emitted logs from smart contracts."
msgstr ""

#: ../../subscriptions.rst:10
msgid ""
"Subscriptions require a persistent socket connection between you and the "
"Ethereum client. For that reason, you must use web3.py's "
":class:`~web3.providers.persistent.WebSocketProvider` or "
":class:`~web3.providers.persistent.AsyncIPCProvider` to utilize "
"subscriptions. As it is the more common of the two, examples in this "
"guide will leverage the ``WebSocketProvider``."
msgstr ""

#: ../../subscriptions.rst:13
msgid "An introduction to subscriptions"
msgstr ""

#: ../../subscriptions.rst:15
msgid ""
"When you subscribe to an event – new block headers, for example – you'll "
"receive a subscription ID. The Ethereum client will then maintain a "
"connection to your application and send along any related event until you"
" unsubscribe with that ID. That example in code:"
msgstr ""

#: ../../subscriptions.rst:44
msgid "web3.py's ``subscription_manager``"
msgstr ""

#: ../../subscriptions.rst:46
msgid ""
"The example above is the \"manual\" approach to managing subscriptions. "
"It's not so complicated in the case of listening for new block headers, "
"but things get considerably more complex once you start listening for "
"smart contract event logs or managing multiple subscriptions. As of "
"v7.7.0, web3.py includes some additional convenient subscription "
"management features. We'll step through them now."
msgstr ""

#: ../../subscriptions.rst:50
msgid "1.) The subscription_manager"
msgstr ""

#: ../../subscriptions.rst:52
msgid ""
"The ``w3`` (``AsyncWeb3``) instance has a ``subscription_manager`` "
"module. While you may still use the ``w3.eth.subscribe`` method from the "
"previous example, the ``subscription_manager`` offers an additional way "
"to start one or more subscriptions and provides better management of "
"those subscriptions. We're going to pass in a list of events we want to "
"subscribe to within the ``w3.subscription_manager.subscribe`` method."
msgstr ""

#: ../../subscriptions.rst:64
msgid "2.) Subscription types"
msgstr ""

#: ../../subscriptions.rst:66
msgid ""
"To aid in defining those subscriptions, subscription type classes have "
"been introduced: ``NewHeadsSubscription``, ``PendingTxSubscription``, "
"``LogsSubscription``, and ``SyncingSubscription``. Each class is context "
"aware, meaning it will throw an error if you provide an unexpected data "
"type."
msgstr ""

#: ../../subscriptions.rst:100
msgid "3.) Handlers"
msgstr ""

#: ../../subscriptions.rst:102
msgid ""
"In the example above, there is a handler specified for each subscription."
" These are context-aware functions that you can declare separate from the"
" subscription logic. Within each handler, parse and perform whatever "
"logic you require. Note that in addition to the result being processed, "
"the ``handler_context`` in each handler provides access to your "
"``AsyncWeb3`` instance, the subscription instance, and any custom values "
"declared within the ``handler_context`` of the subscription: ``from "
"web3.utils.subscriptions import LogsSubscriptionContext``"
msgstr ""

#: ../../subscriptions.rst:121
msgid "4.) handle_subscriptions"
msgstr ""

#: ../../subscriptions.rst:123
msgid ""
"Finally, when all your subscriptions are configured, utilize the "
"handle_subscriptions method to begin processing them. If you need to "
"listen for events on multiple chains, create one w3 instance per chain."
msgstr ""

#: ../../subscriptions.rst:143
msgid "5.) Unsubscribing"
msgstr ""

#: ../../subscriptions.rst:145
msgid ""
"If you don't want to subscribe indefinitely to an event, you can "
"unsubscribe at any point. The first example in this post demonstrated the"
" manual approach: ``await w3.eth.unsubscribe(subscription_id)``"
msgstr ""

#: ../../subscriptions.rst:148
msgid ""
"The new handler pattern will keep track of the subscription ID for you "
"however, so the same can be accomplished via the ``handler_context`` "
"without an ID:"
msgstr ""

#: ../../subscriptions.rst:158
msgid ""
"Lastly, if you're wrapping up the whole show, you can reach for "
"``unsubscribe_all`` on the subscription_manager:"
msgstr ""

#: ../../subscriptions.rst:167
msgid "An example"
msgstr ""

#: ../../subscriptions.rst:169
msgid ""
"Let's put all the pieces together. This example will subscribe to new "
"block headers and transfer events from the WETH contract. It should work "
"as written if you provide a WebSocket RPC URL."
msgstr ""

#: ../../subscriptions.rst:225
msgid "Parallelizing subscriptions"
msgstr ""

#: ../../subscriptions.rst:229
msgid ""
"Parallelizing subscriptions does not guarantee that events will be "
"processed in the order they are received. Most events should still be "
"processed in the order they are received, but if a particular handler "
"takes a long time to execute, newer events may be processed first. It is "
"recommended to set the ``parallelize`` flag to ``False`` (default "
"behavior) for subscriptions that depend on the order of events."
msgstr ""

#: ../../subscriptions.rst:236
msgid ""
"If you have multiple subscriptions that can be processed in parallel, you"
" can set the ``parallelize`` flag to ``True`` - either globally on the "
"subscription manager, or individually on each subscription. This control "
"allows the subscription manager to handle subscription processing "
"concurrently. This flag can be set on the manager, as a global setting, "
"or on individual subscriptions. This can help with performance if "
"subscriptions are independent of each other, or do not rely on some "
"external shared state (no race conditions are present)."
msgstr ""

#: ../../subscriptions.rst:244
msgid ""
"Global parallelization is off by default, meaning all subscriptions will "
"be processed sequentially unless you set the ``parallelize`` flag to "
"``True`` on the subscription manager or individual subscriptions."
msgstr ""

#: ../../subscriptions.rst:274
msgid ""
"Global parallelization can also be set on the subscription manager, which"
" will apply to all subscriptions unless overridden by an individual "
"subscription's ``parallelize`` flag:"
msgstr ""

#: ../../subscriptions.rst:311
msgid "FAQ"
msgstr ""

#: ../../subscriptions.rst:315
msgid "How can I subscribe to additional events once my application is running?"
msgstr ""

#: ../../subscriptions.rst:317
msgid ""
"Wherever you have a ``w3`` instance of the ``AsyncWeb3`` object, you can "
"use the ``subscription_manager`` to subscribe to new events."
msgstr ""

#: ../../subscriptions.rst:319
msgid ""
"For example, the handler of one subscription could initialize a new "
"subscription:"
msgstr ""
